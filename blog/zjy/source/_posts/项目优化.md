title: 项目优化
author: zjy
date: 2018-11-05 15:38:51
tags:
---
# 需求调整
# 业务逻辑优化
# 定位卡顿节点，卡顿的sql语句

## 数据库优化
    Mysql数据库的优化技术
            a: 表的设计合理化(符合3NF)
            b: 添加适当索引(index) [四种: 普通索引、主键索引、唯一索引unique、全文索引]
            c: 分表技术(水平分割、垂直分割)
            d: 读写[写: update/delete/add]分离
            e: 存储过程 [模块化编程，可以提高速度]
            f: 对mysql配置优化 [配置最大并发数my.ini, 调整缓存大小 ]
            g: mysql服务器硬件升级
            h: 定时的去清除不需要的数据,定时进行碎片整理(MyISAM)

### 优化表设计，符合3NF规范
      1NF: 即表的列的具有原子性,不可再分解，即列的信息，不能分解, 只有数据库是关系型数据库(mysql/oracle/db2/informix/sysbase/sql server)，就自动的满足1NF
      2NF: 表中的记录是唯一的, 就满足2NF, 通常我们设计一个主键来实现
      3NF: 即表中不要有冗余数据, 就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放. 
      反3NF : 如果推导的过程比较复杂，譬如需要多表联查，效率低下，还不如设计冗余字段，增加效率。这个看实际情况来设计
      
        ps:
        关系型数据库: mysql/oracle/db2/informix/sysbase/sql server
        非关系型数据库: (特点: 面向对象或者集合)
        NoSql数据库: MongoDB(特点是面向文档)

### 添加适当索引

#### 索引优缺点
      优点：
         1、所有的MySql列类型(字段类型)都可以被索引，也就是可以给任意字段设置索引
         2、大大加快数据的查询速度
      缺点：
         1、创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加
         2、索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值 
         3、当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。
        
     使用原则：
         通过上面说的优点和缺点，我们应该可以知道，并不是每个字段度设置索引就好，也不是索引越多越好，而是需要自己合理的使用。
         1、对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引，
         2、数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。
         3、在一同值少的列上(字段上)不要建立索引，比如在学生表的"性别"字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。

#### 索引分类
      注意：索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引
              MyISAM和InnoDB存储引擎：只支持BTREE索引， 也就是说默认使用BTREE，不能够更换
              MEMORY/HEAP存储引擎：支持HASH和BTREE索引
         1、索引我们分为四类来讲 单列索引(普通索引，唯一索引，主键索引)、组合索引、全文索引、空间索引、
            1.1、单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。 这里不要搞混淆了。
               1.1.1、普通索引：
                   MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。
               1.1.2、唯一索引：
                    索引列中的值必须是唯一的，但是允许为空值，
               1.1.3、主键索引：
                    是一种特殊的唯一索引，不允许有空值。
            1.2、组合索引
                 在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。这个如果还不明白，等后面举例讲解时在细说　
            1.3、全文索引
                 全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文
                 字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有"你是个大煞笔，二货 ..." 通过
                 大煞笔，可能就可以找到该条记录。这里说的是可能，因为全文索引的使用涉及了很多细节，我们只需要知道这个大概意思，如果感兴趣进一步深入使用它，
                 那么看下面测试该索引时，会给出一个博文，供大家参考。
            1.4、空间索引
                 空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。
                 在创建空间索引时，使用SPATIAL关键字。
                 要求，引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。具体细节看下面　　　

	ps:具体创建索引方法请谷歌。。我也记不清

#### 索引失效情况
导致索引失效的一些情况


           1．隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误.
             由于表的字段tu_mdn定义为varchar2(20),但在查询时把该字段作为number类型以where条件传给Oracle,这样会导致索引失效.
             错误的例子：select * from test where tu_mdn=13333333333;
             正确的例子：select * from test where tu_mdn='13333333333';
           2. 对索引列进行运算导致索引失效,我所指的对索引列进行运算包括(+，-，*，/，! 等)
             错误的例子：select * from test where id-1=9;
             正确的例子：select * from test where id=10;
           3. 使用Oracle内部函数导致索引失效.对于这样情况应当创建基于函数的索引.
             错误的例子：select * from test where round(id)=10; 说明，此时id的索引已经不起作用了
             正确的例子：首先建立函数索引，create index test_id_fbi_idx on test(round(id));然后 select * from test where round(id)=10; 这时函数索引起作用了
           4. 以下使用会使索引失效，应避免使用；
             a. 使用 <> 、not in 、not exist、!=
             b. like "%_" 百分号在前（可采用在建立索引时用reverse(columnName)这种方法处理）
             c. 单独引用复合索引里非第一位置的索引列.应总是使用索引的第一个列，如果索引是建立在多个列上, 只有在它的第一个列被where子句引用时，优化器才会选择使用该索引。
             d. 字符型字段为数字时在where条件里不添加引号.
             e. 当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况。
           5. 不要将空的变量值直接与比较运算符（符号）比较。
           如果变量可能为空，应使用 IS NULL 或 IS NOT NULL 进行比较，或者使用 ISNULL 函数。
           6. 不要在 SQL 代码中使用双引号。
           因为字符常量使用单引号。如果没有必要限定对象名称，可以使用（非 ANSI SQL 标准）括号将名称括起来。
           7. 将索引所在表空间和数据所在表空间分别设于不同的磁盘chunk上，有助于提高索引查询的效率。
           8. Oracle默认使用的基于代价的SQL优化器（CBO）非常依赖于统计信息，一旦统计信息不正常，会导致数据库查询时不使用索引或使用错误的索引。
           一般来说，Oracle的自动任务里面会包含更新统计信息的语句，但如果表数据发生了比较大的变化（超过20%）,可以考虑立即手动更新统计信息，例如：analyze table abc compute statistics，但注意，更新   统计信息比较耗费系统资源，建议在系统空闲时执行。
           9. Oracle在进行一次查询时，一般对一个表只会使用一个索引.
             因此，有时候过多的索引可能导致Oracle使用错误的索引，降低查询效率。例如某表有索引1（Policyno）和索引2（classcode），如果查询条件为policyno = ‘xx’ and classcode = ‘xx’，则系统有可能会使用索   引2，相较于使用索引1，查询效率明显降低。
           10. 优先且尽可能使用分区索引。

### 读写分离
    让主数据库（master）处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库（slave）处理SELECT查询操作。
    读写分离，解决的是，数据库的写入，影响了查询的效率
    
    读写分离实现：
    1 代码内部逻辑实现
    	代码内部判断insert ，select等语句，进行路由分类转发
    2 通过中间件实现
    	mysql_proxy  Atlas  Amoeba
        
    主从:AB
    
 mysql_proxy 原理图     
![upload successful](/paste/pasted-8.png)
![upload successful](/paste/pasted-9.png)


    
### 分库分表(水平分割、垂直分割)
    先读写分离，不能解决问题再分库分表
    垂直分割：按业务将不同表分布到不同库。垂直切分是指按照业务将表进行分类，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面
    水平分割：同一个表拆到不同的数据库中